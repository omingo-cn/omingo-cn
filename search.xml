<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k8s上运行mysql</title>
      <link href="/2019/07/12/k8s%E4%B8%8A%E8%BF%90%E8%A1%8Cmysql/"/>
      <url>/2019/07/12/k8s%E4%B8%8A%E8%BF%90%E8%A1%8Cmysql/</url>
      
        <content type="html"><![CDATA[<p>k8s中跑mysql要求:</p><ol><li>可通过节点ip访问mysql.</li><li>pod可以访问mysql.</li><li>机器重启后mysql数据不丢失.</li></ol><pre><code class="yml">apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: mysqlspec:  template:    metadata:      labels:        app: mysql    spec:      nodeName: node1 #指定pod只能调度到node1上      containers:      - image: mysql:5.6        name: mysql        env:        - name: &#39;MYSQL_ROOT_PASSWORD&#39;          value: &#39;root&#39;        - name: &quot;TZ&quot;          value: &quot;Asia/Shanghai&quot; #指定mysql容器的时区为CST,默认为UTC        ports:        - containerPort: 3306        volumeMounts:        - mountPath: /var/lib/mysql          name: mysql-volume      volumes:      - name: mysql-volume # 使用hostPath讲数据文件挂载出来        hostPath:          path: /data/mysql---apiVersion: v1kind: Servicemetadata:   name: mysqlspec:  selector:    app: mysql  type: NodePort  ports:  - port: 3306 # pod中通过 mysql:3306 访问    nodePort: 32306 # 集群外部通过 节点IP:32306访问</code></pre><p>使用hostPath类型的volume持久化数据文件,nodeName固定调度节点,NodePort暴露服务.<br>肥肠地方便.</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s安装指南</title>
      <link href="/2019/06/24/k8s%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
      <url>/2019/06/24/k8s%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="准备机器"><a href="#准备机器" class="headerlink" title="准备机器"></a>准备机器</h2><p>官方要求:</p><ul><li>ubuntu16.04+</li><li>内存≥2G</li><li>cpu≥2</li><li>机器间网络互通</li><li>每个节点的hostname,mac地址,product_uuid要唯一.</li><li>swap要禁用.</li></ul><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><table><thead><tr><th>ip</th><th>角色</th><th>hostname</th><th>配置</th><th>系统</th></tr></thead><tbody><tr><td> 192.168.1.36</td><td>master</td><td>node1</td><td>2G/2C</td><td>ubuntu18.04</td></tr><tr><td> 192.168.1.37</td><td>node</td><td>node2</td><td>2G/2C</td><td>ubuntu18.04</td></tr><tr><td> 192.168.1.38</td><td>node</td><td>node3</td><td>2G/2C</td><td>ubuntu18.04</td></tr></tbody></table><p>我使用的是vbox,网络模式使用桥接.安装一个完一个虚拟机之后,复制除另外两个,复制的时候选中”重新初始化所有网卡的MAC地址”<br><img src="/2019/06/24/k8s安装指南/1.png"></p><h3 id="修改主机名称-所有节点"><a href="#修改主机名称-所有节点" class="headerlink" title="修改主机名称(所有节点)"></a>修改主机名称(所有节点)</h3><pre><code class="bash">sudo sed -i &#39;/preserve_hostname: false/c\preserve_hostname: true&#39; /etc/cloud/cloud.cfg &amp;&amp; sudo hostnamectl set-hostname {新hostname}</code></pre><p>退出重新登录后hostname就会改变.<br>参考:<a href="https://askubuntu.com/questions/1028633/host-name-reverts-to-old-name-after-reboot-in-18-04-lts" target="_blank" rel="noopener">修改ubuntu18.04hostname</a></p><h3 id="修改为静态地址-所有节点"><a href="#修改为静态地址-所有节点" class="headerlink" title="修改为静态地址(所有节点)"></a>修改为静态地址(所有节点)</h3><ol><li>执行命令<code>sudo vim /etc/netplan/50-cloud-init.yaml</code></li><li>更改配置<pre><code class="yml">network:   ethernets:       enp0s3:           addresses: [192.168.1.37/24] # 静态ip           gateway4: 192.168.1.1 # 网关           nameservers:                   addresses: [192.168.1.254] #DNS   version: 2</code></pre></li><li>使设置生效<code>sudo netplan apply</code></li></ol><p>参考 <a href="https://ywnz.com/linuxjc/1491.html" target="_blank" rel="noopener">ubuntu 18.04 netplan yaml配置固定IP地址</a></p><h3 id="关闭swap-所有节点"><a href="#关闭swap-所有节点" class="headerlink" title="关闭swap(所有节点)"></a>关闭swap(所有节点)</h3><p><code>sudo swapoff -a</code><br><code>sudo vim /etc/fstab</code> 注释掉 swap那一行,如下:</p><pre><code>UUID=f229223e-9634-11e9-9470-080027aa5c7f / ext4 defaults 0 0#/swap.img    none    swap    sw    0    0  </code></pre><h3 id="检查-mac地址-product-uuid-所有节点"><a href="#检查-mac地址-product-uuid-所有节点" class="headerlink" title="检查 mac地址,product_uuid(所有节点)"></a>检查 mac地址,product_uuid(所有节点)</h3><pre><code class="bash">ip link # 查看macsudo cat /sys/class/dmi/id/product_uuid # 查看product_uuid</code></pre><p>一般情况下不会冲突.(反正我没遇到这种情况☺)</p><h2 id="安装docker-所有节点"><a href="#安装docker-所有节点" class="headerlink" title="安装docker(所有节点)"></a>安装docker(所有节点)</h2><p>国内网络环境,你懂得.<br>使用阿里云提供的方案快速安装: <code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code><br><a href="https://yq.aliyun.com/articles/110806" target="_blank" rel="noopener">Docker CE 镜像源站</a></p><p>请自行配置docker镜像加速.</p><h2 id="安装kubeadm-kubelet-and-kubectl-所有节点"><a href="#安装kubeadm-kubelet-and-kubectl-所有节点" class="headerlink" title="安装kubeadm, kubelet and kubectl(所有节点)"></a>安装kubeadm, kubelet and kubectl(所有节点)</h2><p>安装k8s需要安装这三个包:</p><table><thead><tr><th>名称</th><th>作用 </th></tr></thead><tbody><tr><td> kubeadm</td><td>用来引导集群 </td></tr><tr><td> kubelet</td><td>在群集中的所有计算机上运行的组件，并执行诸如启动pod和容器之类的操作</td></tr><tr><td> kubectl</td><td>用来和集群通信的命令行工具</td></tr></tbody></table><p>国内网络环境,这回应该懂了吧…</p><pre><code class="bash"># 使用root操作sudo su apt-get update &amp;&amp; apt-get install -y apt-transport-httpscurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF  apt-get updateapt-get install -y kubelet kubeadm kubectl</code></pre><h3 id="准备镜像-所有节点"><a href="#准备镜像-所有节点" class="headerlink" title="准备镜像(所有节点)"></a>准备镜像(所有节点)</h3><p>集群初始化的时候需要从k8s.gcr.io拉取镜像,但是国内网络环境,你懂得.</p><ol><li><code>kubeadm config images list</code> 查看使用到的镜像<pre><code>kubeadm config images listk8s.gcr.io/kube-apiserver:v1.15.0k8s.gcr.io/kube-controller-manager:v1.15.0k8s.gcr.io/kube-scheduler:v1.15.0k8s.gcr.io/kube-proxy:v1.15.0k8s.gcr.io/pause:3.1k8s.gcr.io/etcd:3.3.10k8s.gcr.io/coredns:1.3.1</code></pre></li><li>手动获取一下镜像<pre><code>#上面那一堆复制下来images=( k8s.gcr.io/kube-apiserver:v1.15.0 k8s.gcr.io/kube-controller-manager:v1.15.0 k8s.gcr.io/kube-scheduler:v1.15.0 k8s.gcr.io/kube-proxy:v1.15.0 k8s.gcr.io/pause:3.1 k8s.gcr.io/etcd:3.3.10 k8s.gcr.io/coredns:1.3.1)for imageName in ${images[@]} ; do imageName=${imageName##*/} docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageNamedone </code></pre><h2 id="初始化集群-master节点"><a href="#初始化集群-master节点" class="headerlink" title="初始化集群(master节点)"></a>初始化集群(master节点)</h2></li></ol><pre><code># 因为使用flannel网络插件,需要在kubeadm init 时设置 --pod-network-cidr=10.244.0.0/16sudo kubeadm init --pod-network-cidr=10.244.0.0/16</code></pre><h2 id="配置授权信息-master节点"><a href="#配置授权信息-master节点" class="headerlink" title="配置授权信息(master节点)"></a>配置授权信息(master节点)</h2><p>集群初始化后有提示</p><pre><code>mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><h2 id="添加网络插件-master节点"><a href="#添加网络插件-master节点" class="headerlink" title="添加网络插件(master节点)"></a>添加网络插件(master节点)</h2><p>执行<code>kubectl get pods -A</code> 会发现coredns状态为pending.以为还没有安装网络插件,所有和网络相关的pod都会为pending.<br>集群初始化完成后也有提示<code>You should now deploy a pod network to the cluster.</code><br>添加网络插件:</p><pre><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>稍等片刻,再次执行 <code>kubectl get pods -A</code> ,所有POD 都running了.</p><h2 id="设置master节点也可以运行Pod"><a href="#设置master节点也可以运行Pod" class="headerlink" title="设置master节点也可以运行Pod"></a>设置master节点也可以运行Pod</h2><p>kubernetes官方默认策略是worker节点运行Pod，master节点不运行Pod。如果只是为了开发或者其他目的而需要部署单节点集群，可以通过以下的命令设置<br><code>kubectl taint nodes --all node-role.kubernetes.io/master-</code></p><h2 id="加入节点-worker节点"><a href="#加入节点-worker节点" class="headerlink" title="加入节点(worker节点)"></a>加入节点(worker节点)</h2><p>集群初始化完成后也有提示:</p><pre><code>Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.1.36:6443 --token 9wujqe.xfc5msp9l3i9g9s8 \    --discovery-token-ca-cert-hash sha256:1c67699dbf329cceff693a37a6b3f2c4d706901673343a24c872d802a7ed3433</code></pre><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>在master执行:</p><pre><code>kubectl get nodes #此时应该有三个节点NAME    STATUS   ROLES    AGE    VERSIONnode1   Ready    master   36m    v1.15.0node2   Ready    &lt;none&gt;   8m2s   v1.15.0node3   Ready    &lt;none&gt;   29s    v1.15.0</code></pre><p>创建个deployment试试</p><pre><code>kubectl run my-nginx --image=nginx --replicas=3 --port=80# 稍等片刻kubectl get pods -o wide# 应该这样的NAME                        READY   STATUS    RESTARTS   AGE   IP           NODE    NOMINATED NODE   READINESS GATESmy-nginx-756fb87568-ssxj5   1/1     Running   0          94s   10.244.0.4   node1   &lt;none&gt;           &lt;none&gt;my-nginx-756fb87568-x2mtk   1/1     Running   0          94s   10.244.2.2   node3   &lt;none&gt;           &lt;none&gt;my-nginx-756fb87568-zkjxj   1/1     Running   0          94s   10.244.1.2   node2   &lt;none&gt;           &lt;none&gt;</code></pre><p>创建个service试试</p><pre><code>kubectl expose deployment my-nginx --name=my-nginx --port 80 --target-port 80 --external-ip 192.168.1.36</code></pre><p>打开浏览器访问一下 192.168.1.36,nginx首页.<br><img src="/2019/06/24/k8s安装指南/2.png"><br>可以愉快的玩耍了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内microk8s安装指南</title>
      <link href="/2019/06/21/%E5%9B%BD%E5%86%85microk8s%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
      <url>/2019/06/21/%E5%9B%BD%E5%86%85microk8s%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>microk8s 是一个专门为开发人员设计的轻量级单节点k8s包.可以用来替代minikube进行学习.</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由gfw,安装microk8s后会发现docker image无法下载的问题.(详细安装步骤参见 <a href="https://microk8s.io/#quick-start" target="_blank" rel="noopener">https://microk8s.io/#quick-start</a>)</p><p><code>microk8s.kubectl describe pods -A</code> 会有错误提示<br> <em>[ERROR ImagePull]: failed to pull image [k8s.gcr.io/pause:3.1]</em></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><pre><code class="bash">docker pull mirrorgooglecontainers/pause:3.1docker pull mirrorgooglecontainers/heapster-influxdb-amd64:v1.3.3docker pull mirrorgooglecontainers/heapster-grafana-amd64:v4.4.3docker pull mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.8.3docker pull mirrorgooglecontainers/heapster-amd64:v1.5.2docker pull mirrorgooglecontainers/k8s-dns-dnsmasq-nanny-amd64:1.14.7docker pull mirrorgooglecontainers/k8s-dns-kube-dns-amd64:1.14.7docker pull mirrorgooglecontainers/k8s-dns-sidecar-amd64:1.14.7docker tag mirrorgooglecontainers/pause:3.1 k8s.gcr.io/pause:3.1docker tag mirrorgooglecontainers/heapster-influxdb-amd64:v1.3.3 k8s.gcr.io/heapster-influxdb-amd64:v1.3.3docker tag mirrorgooglecontainers/heapster-grafana-amd64:v4.4.3 k8s.gcr.io/heapster-grafana-amd64:v4.4.3docker tag mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.8.3 k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3docker tag mirrorgooglecontainers/heapster-amd64:v1.5.2 k8s.gcr.io/heapster-amd64:v1.5.2docker tag mirrorgooglecontainers/k8s-dns-dnsmasq-nanny-amd64:1.14.7 gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.7docker tag mirrorgooglecontainers/k8s-dns-kube-dns-amd64:1.14.7 gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.7docker tag mirrorgooglecontainers/k8s-dns-sidecar-amd64:1.14.7 gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.7docker save k8s.gcr.io/pause &gt; pause.tardocker save k8s.gcr.io/heapster-influxdb-amd64 &gt; heapster-influxdb-amd64.tardocker save k8s.gcr.io/heapster-grafana-amd64 &gt; heapster-grafana-amd64.tardocker save k8s.gcr.io/kubernetes-dashboard-amd64 &gt; kubernetes-dashboard-amd64.tardocker save k8s.gcr.io/heapster-amd64 &gt; heapster-amd64.tardocker save gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64 &gt; k8s-dns-dnsmasq-nanny-amd64.tardocker save gcr.io/google_containers/k8s-dns-kube-dns-amd64 &gt; k8s-dns-kube-dns-amd64.tardocker save gcr.io/google_containers/k8s-dns-sidecar-amd64 &gt; k8s-dns-sidecar-amd64.tarmicrok8s.ctr -n k8s.io image import pause.tarmicrok8s.ctr -n k8s.io image import heapster-influxdb-amd64.tarmicrok8s.ctr -n k8s.io image import heapster-grafana-amd64.tarmicrok8s.ctr -n k8s.io image import kubernetes-dashboard-amd64.tarmicrok8s.ctr -n k8s.io image import heapster-amd64.tarmicrok8s.ctr -n k8s.io image import k8s-dns-dnsmasq-nanny-amd64.tarmicrok8s.ctr -n k8s.io image import k8s-dns-kube-dns-amd64.tarmicrok8s.ctr -n k8s.io image import k8s-dns-sidecar-amd64.tar</code></pre><p>然后就可以愉快的玩耍了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用log-pilot收集docker容器日志</title>
      <link href="/2019/05/21/%E4%BD%BF%E7%94%A8log-pilot%E6%94%B6%E9%9B%86docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/"/>
      <url>/2019/05/21/%E4%BD%BF%E7%94%A8log-pilot%E6%94%B6%E9%9B%86docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>本文档介绍一款新的 Docker 日志收集工具：log-pilot。log-pilot 是阿里云提供的日志收集镜像。我们可以在每台机器上部署一个 log-pilot 实例，就可以收集机器上所有 Docker 应用日志。(注意：只支持Linux版本的Docker，不支持Windows/Mac版)。</p><p>log-pilot 具有如下特性：</p><ul><li>一个单独的 log 进程收集机器上所有容器的日志。不需要为每个容器启动一个 log 进程。</li><li>支持文件日志和 stdout。docker log dirver 亦或 logspout 只能处理 stdout，log-pilot 不仅支持收集 stdout 日志，还可以收集文件日志。</li><li>声明式配置。当您的容器有日志要收集，只要通过 label 声明要收集的日志文件的路径，无需改动其他任何配置，log-pilot 就会自动收集新容器的日志。</li><li>支持多种日志存储方式。无论是强大的阿里云日志服务，还是比较流行的 elasticsearch 组合，甚至是 graylog，log-pilot 都能把日志投递到正确的地点。</li><li><p>开源。log-pilot 完全开源，您可以从 Git项目地址 <a href="https://github.com/AliyunContainerService/log-pilot" target="_blank" rel="noopener">下载代码</a>。如果现有的功能不能满足您的需要，欢迎提 issue。</p><img src="/2019/05/21/使用log-pilot收集docker容器日志/1.png"></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>先有应用使用单机docker部署,需要将docker容器产生的日志发送到kafka.</p><p>首先部署log-pilot镜像,用来感知容器日志并发送日志到目的地:</p><pre><code>docker run --name log-pilot -d \-v /var/run/docker.sock:/var/run/docker.sock \-v /etc/localtime:/etc/localtime \-v /:/host:ro \--cap-add SYS_ADMIN \-e LOGGING_OUTPUT=kafka \ #选择输入类型 kafka-e KAFKA_BROKERS=kafka:9092 \ # 配置kafka的地址registry.cn-hangzhou.aliyuncs.com/acs/log-pilot:0.9.5-filebeat</code></pre><p>运行docker应用的时候只需要增加标签 aliyun.$name.*:<br>如:</p><pre><code>docker run -it --rm -p 10080:8080 \-v /usr/local/tomcat/logs \--label aliyun.logs.catalina=stdout \ --label aliyun.logs.access=/usr/local/tomcat/logs/localhost_access_log.*.txt \tomcat</code></pre><p>还可以自定义输入的target:<br>aliyun.$name.target=&lt;target&gt;<br>&lt;target&gt;:自定义字符串,分别指代:</p><ol><li>eleasticsearch-&gt;index</li><li>kafka-&gt;topic</li></ol><p>参考文章:<br><a href="https://yq.aliyun.com/articles/674327" target="_blank" rel="noopener">日志采集利器</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兄弟俩畅游Tomcat城市的SpringMVC科技园区</title>
      <link href="/2019/05/09/%E5%85%84%E5%BC%9F%E4%BF%A9%E7%95%85%E6%B8%B8Tomcat%E5%9F%8E%E5%B8%82%E7%9A%84SpringMVC%E7%A7%91%E6%8A%80%E5%9B%AD%E5%8C%BA/"/>
      <url>/2019/05/09/%E5%85%84%E5%BC%9F%E4%BF%A9%E7%95%85%E6%B8%B8Tomcat%E5%9F%8E%E5%B8%82%E7%9A%84SpringMVC%E7%A7%91%E6%8A%80%E5%9B%AD%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>今天看到一片文章挺有意思的,转了过来.</p><p>来自公众号：编程新说  李新杰</p><h2 id="Tomcat城市"><a href="#Tomcat城市" class="headerlink" title="Tomcat城市"></a>Tomcat城市</h2><p>Tomcat这座城市的历史相当悠久了，经历过几次大的变迁后，呈现出非常明显的地域特征。<br>从城市往西走，过了城乡结合部以后，可以说是满目疮痍、一片破败，这就是Servlet地区，这座城市一开始就是从这个地方发展起来的。<br>哎，这都是很多年前的老黄历了，只有一些老人才知道这些，现在的年轻人都不到这个地方来了，于是就荒芜了，快成无人区了。<br>城市的中央是Struts地区，人们习惯称它为老城区。矮矮的居民楼，窄窄的街道，三五成群的老旧工厂。<br>虽然现在没落了，但是置身其中，你依然能够感受到它曾经辉煌过的痕迹，那时也应该是灯红酒绿、人声鼎沸、好不热闹。<br>现在这里只剩下一些老年人了，年轻人觉得这里太陈旧了，都纷纷搬走了，偶尔能见到几个，那是回来看望父母的。<br>从城市往东走，出了老城进入新区，高楼大厦、玻璃幕墙，大宽马路、人流成河。红灯绿灯、南来北往，车声人声、声声不息。<br>这里充满了大量的年轻人，节奏感、时尚感、科技感，有梦想、有压力、有希望。没错，这就是大名鼎鼎、闻名遐迩的SpringMVC地区。<br>技术的发展就像城市的变迁，有新区就有老城。所谓长江后浪推前浪，一浪更比一浪浪，真是够浪，嗯，golang。</p><blockquote><p>第一代web应用Jsp+Servlet，现在基本没人用了，成了无人区了。<br>第二代web应用Struts1.x、Struts2，曾经辉煌时很多人用，现在都是进入维护期的老项目了，就像老城区。<br>第三代web应用SpringMVC，现在如日中天，依然是主战场，就如同城市的新区。</p><footer><strong>[编程新说]</strong></footer></blockquote><p>不过SpringMVC并非固若金汤，它的挑战者已经出现，就是响应式web应用，它现在不仅要面临外患，还有来自内忧的困扰。</p><h2 id="破旧的火车站"><a href="#破旧的火车站" class="headerlink" title="破旧的火车站"></a>破旧的火车站</h2><p>request奉主人之命，坐了“一夜”的火车，“长途跋涉”后来到了tomcat城市，按照约定，他的弟弟response会来这里接他。request刚下了车，他弟弟就迎了上来，没想到他跑到站台上来接自己了。<br>request边走边四处打量着，这座车站虽然略显破旧，但结构设计合理，层层叠叠、环环相扣，真是建筑之美啊。<br>他突然意识到自己是第一次来这里，还不知道路怎么走，看到不远处有一老者在扫地，打算前去问路。眼看就要到了，不料被四个人“截胡”了。<br>其中两个人说他们要找一个叫MyServlet的人，老者说出门往西走就行了。另外两个人说要找一个叫<code>FilterDispatcher</code>的人，老者说出门往前走就行了。<br>看着他们四人离去的背影，老者无奈地摇了摇头，又自顾自地开始扫地。request上去询问为何这般，老者解释道，这四位可是稀客啊，现在像他们这样的人已经很少了。几乎都是去找<code>DispatcherServlet</code>的人。<br>request说道，我们就是要去找<code>DispatcherServlet</code>呀，老者说，出门跟着人流走，保证能找到。为了礼貌，request询问了老者的姓名，老者说，他是Wrapper，在这里工作十几年了。<br>request和response跟老者道谢后，就离开了。出门后，好不容易挤上了一辆公交，一路向东奔去。</p><blockquote><p><em>MyServlet</em> 一般是一个刚毕业的学生起的名字。<br><em>FilterDispatcher</em> 是Struts2的核心控制器。<br><em>DispatcherServlet</em> 是SpringMVC的核心控制器。<br><em>Wrapper</em> 是Tomcat内部的一种容器组件，负责<em>Servlet</em>的调用执行。</p><footer><strong>[编程新说]</strong></footer></blockquote><h2 id="SpringMVC科技园区"><a href="#SpringMVC科技园区" class="headerlink" title="SpringMVC科技园区"></a>SpringMVC科技园区</h2><p> “前方到站SpringMVC科技园，有下车的乘客，请携带好随身物品，从后门下车”，两兄弟好不容易挤到后门，下车了。<br>眼前的这个科技园四四方方，里面的高大建筑布局合理。门前的宽大道路干净笔直，向南北无限延伸。旁边的小路绿树成荫、鲜花满地。<br>这里的一切都极具现代化都市气息，兄弟俩早已忘我。一阵急促的嘈杂声响起，哦，原来是绿灯亮了，可以过马路了，随机又淹没在人群中。<br>两兄弟在园区门口被保安拦下，“恁俩是弄啥嘞？”，保安问道。两兄弟一听，咦，河南人，心里乐了。说道，“老乡，俺是来找一个叫<code>DispatcherServlet</code>的人”。保安道，“那中，他一般都可忙啦，恁俩先去那边树荫下凉快凉快吧”。<br>一会儿功夫，有一个中年微胖男人来到了门口，就是他了。两兄弟表明来意后，request递上了一张“介绍信”，上面似乎写着：</p><pre><code>POST /users HTTP/1.1Content-Type: application/x-wwww-form-urlencodedAccept: application/jsonusername=abc&amp;password=1qaz@WSX&amp;email=xyz@456.com&amp;age=30</code></pre><p><code>DispatcherServlet</code>看后，心里暗骂一句，这是哪个小兔崽子在写着玩呢。不过人既然已经来了，那就按照程序走吧。<br>他就带着两兄弟来到了一个房间门口，说先进去检查一下，看看有没有“携带大件行李物品”。只见response准备进去，一把被他拉回来，说你不用去，只要你哥哥去就行了。<br>request来到门前，只见上面写着checkMultipart，推门而入，有个叫<code>MultipartResolver</code>的工作人员，正准备对他搜查，一看<code>Content-Type</code>，嘟囔着说原来只是普通表单提交没有附件，随即放弃了对request的检查，让他直接出去了。<br>request一脸懵逼，他原以为来到这里后，会有人专门带着他参观，给他讲解，端茶倒水啥的。谁知就像进了医院体检一样，拿个“单子”乱跑。<br>正在郁闷着的request在走过一个叫getHandler的房间门口时，被叫停了，他知道又该进去被检查了。一个叫<code>RequestMappingHandlerMapping</code>的家伙坐在电脑后面，request赶紧递上自己的单子。<br>那个家伙瞄了一眼单子后，在输入框里敲上“POST /users”关键字，点击搜索按钮，只见结果的第一条就是一个叫<code>UserController</code>的小伙子。并把这个小伙子的信息打印到一张纸上给了request。<br>request接过纸，边往外走边看，只见上面写着：</p><pre><code>HandlerExecutionChain:  handler:    HandlerMethod:      beanType: UserController      method: registerUser      parameters: [User]  interceptors: null</code></pre><p>request又是一脸懵逼，这都什么玩意儿呀。不过定睛一看，发现了熟悉的字眼儿。如UserController、registerUser、User。<br>request隐隐约约当中记得自己的主人写过一些和他们相关的东西，好像是这样的：</p><pre><code class="java">@RequestMapping(&quot;/users&quot;)@RestControllerpublic class UserController{  @Autowired  private IUserService userService;  @PostMapping  public RestResult registerUser(@ModelAttribute(&quot;user&quot;)User user){    userService.addUser(user);    return new RestResult(0,&quot;seccess&quot;);  }}public class User{  private String username;  private String password;  private String email;  private Integer age;}public class RestResult{  private Integer code;  private String desc;}</code></pre><p>此时，request仿佛明白了，刚才那个家伙根据我的“单子”，使用电脑搜索，为我开了个“方子”。说<code>UserController</code>这个小伙子的<code>registerUser</code>方法“可以治我的病”，其中<code>User</code>是方法入参。<br>request正准备沾沾自喜，怎么脑门突然一阵疼痛，莫非是得意忘形受了诅咒，哦，不是，是撞到门上了。揉了揉脑袋，便出了门。<br>三人一行继续往前走，request心里明白，现在这充其量叫作“做检查”，后面非给我来一个“大的修里”不可。又在一个叫做<code>getHandlerAdapter</code>的房间门口停住了。<br>不过这次两兄弟都在外面等着，是<code>DispatcherServlet</code>亲自拿着给request开的“方子”进去了。不一会他就出来了，又带出来一位叫<code>RequestMappingHandlerAdapter</code>的人，说这位是高级技工，由他来完成一部分核心工作。<br>这位高级技工带着两兄弟向自己的地盘走去，来到了一个写着handle的门前，推开门一起进入。这是一个非常大的房间，里面有好多的工作人员和机器设备，两兄弟明白，是时候了，重大的事情将在这里发生。<br>高级技工让两兄弟躺到工作台上，然后让所有人员各就各位，接着就是“生死看淡，不服就干”，于是，一切井然有序地开始了。<br>一个叫<code>ServletInvocableHandlerMethod</code>的家伙是本次的主要操盘手，他依次点名了自己的队友和检查了要用的设备，一切正常，下面正式开始了。<br>操盘手拿到给request开的“方子”，发现需要调用<code>registerUser</code>方法，于是先通过反射拿到这个方法的参数，再经过一番解析后变成了<code>MethodParameter</code>类型啦，对，它就表示方法的参数。<br>操盘手让他的队友<code>ParameterNameDiscoverer</code>去查看下参数的名字是什么，队友拿到参数，惊奇地发现上面有个<code>@ModelAttribute(&quot;user&quot;)</code>注解，于是从注解中读到了user，它就是参数的名字了。<br>操盘手又让他的队友<code>HandlerMethodArgumentResolver</code>去想办法把参数值搞定，队友也发现了<code>@ModelAttribute(&quot;user&quot;)</code>注解，说明这个参数是个模型数据，而且不是简单类型。于是先打开设备<code>ModelAndViewContainer</code>，发现设备里并没有一个叫user的数据。<br>队友明白，需要自己来生成这样的一个参数了。先拿到参数类型<code>User</code>，然后反射一下构造函数，发现正好有个默认无参的，通过它就new出了一个<code>User</code>类型的对象了。<br>队友接着反射一下它的属性，发现有4个，<em>username</em>、<em>password</em>、<em>email</em>、<em>age</em>。接着从request中恰巧能找出这4个名称的值，使用<code>WebDataBinderFactory</code>设备把数据类型合理转化后，设置给了user对象。这样队友就把参数值给准备好了。<br>有了<code>registerUser</code>方法和<code>user</code>参数后，还要知道在哪个对象上调用才行啊，于是操盘手根据方法所在的类型<code>UserController</code>，去容器中找到它的bean实例，接着就在该实例上通过反射发起了方法调用，传进去入参，并获取返回结果。<br>操盘手拿到返回结果，简单检查后发现返回结果不为null，再检查request的弟弟response，发现没有出现错误，而且还没有执行结束。于是在ModelAndViewContainer设备上把该请求标记为尚未处理完。<br>然后把返回结果交给队友<code>HandlerMethodReturnValueHandler</code>去处理，队友发现方法所在的类<code>UserController</code>上标有<code>@ResponseBody</code>注解（是作为<code>@RestController</code>的元注解出现的），瞬间就明白方法的返回值是直接作为web请求的响应的。<br>由于方法的返回值是要直接写入response的，所以就完事了，不用考虑视图解析这一块了。因此队友就在<code>ModelAndViewContainer</code>设备上把本次请求标记为已处理完成。<br>接着就把方法的返回值交给自己的好朋友<code>HttpMessageConverter</code>去处理，好朋友看了request的“单子”一眼，发现上面有<code>Accept：application/json</code>，瞬间也明白了，原来他想要的是JSON格式呀。<br>于是把方法返回值发给合作伙伴Jackson，不一会给他发回了结果，<code>{&quot;code&quot;:0,&quot;desc&quot;:&quot;success&quot;}</code>，好朋友把这个结果甩给了response，叫他拿好了。<br>好朋友完成了队友的任务，队友完成了操盘手的任务，操盘手向高级技工报告，任务已成功完成，请检阅。<br>高级技工本来打算输出一个<code>ModelAndView</code>作为处理结果呢，一检查<code>ModelAndViewContainer</code>设备发现请求已被处理完了。罢了，那就返回一个null吧。<br>门开了，两兄弟出来了，哥哥request已被“消耗殆尽”，弟弟response“满载而归”。<code>DispatcherServlet</code>早已在此等候，他看到高级技工手里只有一个null，于是记录了一句话，“No view rendering, null ModelAndView returned.”。<br>两兄弟和<code>DispatcherServlet</code>道谢后来到了园区大门口，接着和老乡保安挥手告别。此时天色已晚，挤上一辆公交车后，直奔火车站而去。</p><h2 id="就此一别，再无相见"><a href="#就此一别，再无相见" class="headerlink" title="就此一别，再无相见"></a>就此一别，再无相见</h2><p>一路摇摇晃晃来到火车站，天已完全黑透了。返程的列车早已整装待发，弟弟response拉着哥哥的手准备一起上车，被哥哥拒绝了，哥哥说按照剧情应该只有你一个人回去。我的使命已完成了。<br>弟弟并不明白哥哥是什么意思，就问道那我们还能不能再见面。哥哥笑着说傻孩子，“当然可以了”。弟弟高兴地跳上了车。<br>伴着一声长鸣，列车启动，兄弟俩互相挥手告别，列车渐渐消失在黑夜的黑中。弟弟没有看到哥哥微笑的眼角流下了流水。<br>只有哥哥心里明白，他和弟弟，就此一别，再无相见。转身向车站外走去，看到那个老者依然在自顾自的扫着地。<br>黑白无常拿着脚镣手铐，早已在此“恭候多时”，有气无力的request全然无法反抗，任由这“二鬼”拖着去“阴曹地府”接受JVM的轮回。<br>也许老天不愿意看到一个光荣完成使命的人就这般的“烟消玉损”，就派出了钟馗来解救他。钟馗打跑了黑白无常，希望带request“永生”。<br>request婉言拒绝，说我非“三界五行”之外，我依然是凡人，依然有自己的宿命。这是任何人都无法逃离的自然规律。<br>顷刻，一束白光从天而降，洒满request的全身，只见request张开双臂，身轻如燕般的飞向光的源头，不一会便没有了踪迹。</p>]]></content>
      
      
      <categories>
          
          <category> springMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务不停服升级</title>
      <link href="/2019/05/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%81%9C%E6%9C%8D%E5%8D%87%E7%BA%A7/"/>
      <url>/2019/05/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%81%9C%E6%9C%8D%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>有时候我们会给生产环境修复一些比较严重的bug,有没有一种操作可以不停服进行系统升级呢?<br>答案是: <strong>有的</strong>.</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>生产环境部署在阿里云acs-swarm上.<br>服务注册使用eureka.</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先新增新版本的服务实例到生产环境,待新版本服务开始服务之后,通知注册中心下线老版本服务(此时老版本服务不停机,还可以提供服务,只是不会在收到新的请求了),观察监控 等待老版本服务处理完所有请求之后,停机老版本服务,至此完成不停服升级.<br>原理挺简单,关键看操作.</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><ol><li><p>打包要升级的服务,并推送到阿里云镜像服务.</p></li><li><p>进入阿里云后台容器服务,选择服务所在集群,选择相应的应用 点变更配置.<br>找到相应的服务,修改一下服务名称,比如 user-service 修改成 user-service-1,在修改一下服务镜像的版本号,还有acs应用的版本号.<br><strong>注意发布类型要选蓝绿发布</strong></p><img src="/2019/05/09/微服务不停服升级/1.png"><p>确定之后稍等片刻,你会发现,你的容器服务列表新增了一个user-service-1的服务. eureka服务器上user-service的实例也多了一个.</p></li><li><p>通知注册中心下线老版本服务</p><pre><code class="bash">curl -X PUT http://eureka-server:8761/eureka/app/{SERVICE-NAME}/{SERVICE-ID}/status?value=OUT_OF_SERVICE</code></pre><p>把{}中的内容替换成实际内容.<br>你会发现eureka会给这个实例标记一个 红色的 OUT_OF_SERVICE,这样eureka client就不会获取到这个实例的注册信息了,网关也不会讲流量转发到这个实例上来了.</p></li><li><p>看监控下线老版本服务.<br>你会发现老服务的流量会越来越少.</p><img src="/2019/05/09/微服务不停服升级/2.png"><p>当老服务处理完所有请求的时候,到阿里云acs控制台,选择确认发布.</p></li></ol><p>搞定,收工.</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 升级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-data-jpa进阶用法之QueryDSL</title>
      <link href="/2019/05/07/spring-data-jpa%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%E4%B9%8BQueryDSL/"/>
      <url>/2019/05/07/spring-data-jpa%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%E4%B9%8BQueryDSL/</url>
      
        <content type="html"><![CDATA[<p>很多列表查询接口都会有很多复杂的过滤条件。一般都会在controller里面各种拼接条件然后在持久层写好多针对性的查询接口，导致代码可读性差，实现不够优雅。</p><h3 id="QueryDSL"><a href="#QueryDSL" class="headerlink" title="QueryDSL"></a>QueryDSL</h3><p>其实QueryDsl可以很优雅的解决上述场景遇到的问题，QueryDSL是一个Java语言编写的通用查询框架。spring-data-jpa对QueryDsl提供了良好的支持。同时spring-data-jpa也针对web做了一些扩展支持。具体可以参考<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.extensions.querydsl" target="_blank" rel="noopener">spring-data-jpa的官方文档</a>。</p><h3 id="spring-data-jpa的支持"><a href="#spring-data-jpa的支持" class="headerlink" title="spring-data-jpa的支持"></a>spring-data-jpa的支持</h3><p>持久层repository继承<code>QuerydslPredicateExecutor</code>，即可使用QueryDsl查询。</p><pre><code class="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, QuerydslPredicateExecutor&lt;User&gt; {}Predicate predicate = user.firstname.equalsIgnoreCase(&quot;dave&quot;)    .and(user.lastname.startsWithIgnoreCase(&quot;mathews&quot;));userRepository.findAll(predicate);</code></pre><p>web层可以使用 @QuerydslPredicate 标注Predicate。</p><pre><code class="java">@Controllerclass UserController {  @Autowired UserRepository repository;  @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,              Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt; parameters) {    model.addAttribute(&quot;users&quot;, repository.findAll(predicate, pageable));    return &quot;index&quot;;  }}</code></pre><p>这样包含 ?firstname=Dave&amp;lastname=Matthews的查询将会被<code>QuerydslPredicateArgumentResolver</code>解析成 <code>QUser.user.firstname.eq(&quot;Dave&quot;).and(QUser.user.lastname.eq(&quot;Matthews&quot;))</code></p><p>有时候我们的参数并不是和实体的属性一一对应，甚至我们需要隐藏一些不可以用来查询的属性。</p><h3 id="自定义绑定关系"><a href="#自定义绑定关系" class="headerlink" title="自定义绑定关系"></a>自定义绑定关系</h3><p>我们可一通过实现 <code>QuerydslBinderCustomizer</code>这个接口来自定义参数的绑定关系。</p><pre><code class="java">CustomUserQuerydslBinder implements QuerydslBinderCustomizer&lt;QUser&gt; {    @Override    public void customize(QuerydslBindings querydslBindings, QUser qUser) {      //自定义绑定关系      querydslBindings.excludeUnlistedProperties(true);//使用白名单模式      querydslBindings.including( //设置属性白名单            qUser.id,            qUser.name      );      //自定义参数的绑定       querydslBindings.bind(Expressions.stringPath(&quot;sex&quot;)).as(&quot;type&quot;).first((path,value)-&gt;            path.eq(value)        );    }}</code></pre><p>然后在 <code>@QuerydslPredicate(bindings=CustomUserQuerydslBinder.class,root=User.class)</code>中指定。</p>]]></content>
      
      
      <categories>
          
          <category> jpa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qdsl </tag>
            
            <tag> jpa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非spring-cloud项目增加hystrix监控</title>
      <link href="/2019/05/07/%E9%9D%9Espring-cloud%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%8A%A0hystrix%E7%9B%91%E6%8E%A7/"/>
      <url>/2019/05/07/%E9%9D%9Espring-cloud%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%8A%A0hystrix%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="增加依赖"><a href="#增加依赖" class="headerlink" title="增加依赖"></a>增加依赖</h2><p>pom文件中</p><pre><code class="xml"> &lt;dependency&gt;  &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;  &lt;artifactId&gt;hystrix-metrics-event-stream&lt;/artifactId&gt;  &lt;version&gt;${hystrix.version}&lt;/version&gt; &lt;/dependency&gt;</code></pre><h2 id="添加servlet"><a href="#添加servlet" class="headerlink" title="添加servlet"></a>添加servlet</h2><p>web.xml 中</p><pre><code class="xml">  &lt;servlet&gt;    &lt;display-name&gt;HystrixMetricsStreamServlet&lt;/display-name&gt;    &lt;servlet-name&gt;HystrixMetricsStreamServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet    &lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;HystrixMetricsStreamServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/hystrix.stream&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;</code></pre><h2 id="增加Basic安全认证"><a href="#增加Basic安全认证" class="headerlink" title="增加Basic安全认证"></a>增加Basic安全认证</h2><p>web.xml 中</p><pre><code class="xml">&lt;filter&gt;    &lt;filter-name&gt;basicAuthenticationFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.dapeng.cloud.support.web.BasicAuthenticationFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;username&lt;/param-name&gt;      &lt;param-value&gt;xxxx&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;password&lt;/param-name&gt;      &lt;param-value&gt;xxxx&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;basicAuthenticationFilter&lt;/filter-name&gt;    &lt;servlet-name&gt;HystrixMetricsStreamServlet&lt;/servlet-name&gt;  &lt;/filter-mapping&gt;</code></pre><p><code>BasicAuthenticationFilter</code> 源码:</p><pre><code class="java">package com.dapeng.cloud.support.web;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.StringTokenizer;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.codec.binary.Base64;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.StringUtils;public class BasicAuthenticationFilter implements Filter {  private static final Logger LOGGER = LoggerFactory.getLogger(BasicAuthenticationFilter.class);  private String username = &quot;&quot;;  private String password = &quot;&quot;;  private String realm = &quot;Protected&quot;;  public BasicAuthenticationFilter() {  }  public void init(FilterConfig filterConfig) throws ServletException {    this.username = filterConfig.getInitParameter(&quot;username&quot;);    this.password = filterConfig.getInitParameter(&quot;password&quot;);    String paramRealm = filterConfig.getInitParameter(&quot;realm&quot;);    if (StringUtils.hasText(paramRealm)) {      this.realm = paramRealm;    }  }  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {    HttpServletRequest request = (HttpServletRequest)servletRequest;    HttpServletResponse response = (HttpServletResponse)servletResponse;    String authHeader = request.getHeader(&quot;Authorization&quot;);    if (authHeader != null) {      StringTokenizer st = new StringTokenizer(authHeader);      if (st.hasMoreTokens()) {        String basic = st.nextToken();        if (basic.equalsIgnoreCase(&quot;Basic&quot;)) {          try {            String credentials = new String(Base64.decodeBase64(st.nextToken()), &quot;UTF-8&quot;);            LOGGER.debug(&quot;Credentials: &quot; + credentials);            int p = credentials.indexOf(&quot;:&quot;);            if (p != -1) {              String _username = credentials.substring(0, p).trim();              String _password = credentials.substring(p + 1).trim();              if (this.username.equals(_username) &amp;&amp; this.password.equals(_password)) {                filterChain.doFilter(servletRequest, servletResponse);              } else {                this.unauthorized(response, &quot;Bad credentials&quot;);              }            } else {              this.unauthorized(response, &quot;Invalid authentication token&quot;);            }          } catch (UnsupportedEncodingException var13) {            throw new Error(&quot;Couldn&#39;t retrieve authentication&quot;, var13);          }        }      }    } else {      this.unauthorized(response);    }  }  public void destroy() {  }  private void unauthorized(HttpServletResponse response, String message) throws IOException {    response.setHeader(&quot;WWW-Authenticate&quot;, &quot;Basic realm=\&quot;&quot; + this.realm + &quot;\&quot;&quot;);    response.sendError(401, message);  }  private void unauthorized(HttpServletResponse response) throws IOException {    this.unauthorized(response, &quot;Unauthorized&quot;);  }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/07/hello-world/"/>
      <url>/2019/05/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><pre><code class="javascript">console.log(1)</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本博客快捷键说明</title>
      <link href="/2019/05/07/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/05/07/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>快捷键为vim风格的。按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h3><table><thead><tr><th style="text-align:left">Key</th><th style="text-align:left">Descption</th></tr></thead><tbody><tr><td style="text-align:left">ESC</td><td style="text-align:left">1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点</td></tr><tr><td style="text-align:left">i/I</td><td style="text-align:left">获取焦点</td></tr><tr><td style="text-align:left">下</td><td style="text-align:left">向下选择文章</td></tr><tr><td style="text-align:left">上</td><td style="text-align:left">向上选择文章</td></tr><tr><td style="text-align:left">回车</td><td style="text-align:left">打开当前选中的文章，若没有，则默认打开第一个</td></tr></tbody></table><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><table><thead><tr><th style="text-align:left">Key</th><th style="text-align:left">Descption</th></tr></thead><tbody><tr><td style="text-align:left">s/S</td><td style="text-align:left">全屏/取消全屏</td></tr><tr><td style="text-align:left">w/W</td><td style="text-align:left">打开/关闭文章目录</td></tr><tr><td style="text-align:left">j/J</td><td style="text-align:left">向下滑动</td></tr><tr><td style="text-align:left">k/K</td><td style="text-align:left">向上滑动</td></tr><tr><td style="text-align:left">gg/GG</td><td style="text-align:left">到最顶端</td></tr><tr><td style="text-align:left">shift+G/g</td><td style="text-align:left">到最下端</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
