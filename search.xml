<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>兄弟俩畅游Tomcat城市的SpringMVC科技园区</title>
      <link href="/2019/05/09/%E5%85%84%E5%BC%9F%E4%BF%A9%E7%95%85%E6%B8%B8Tomcat%E5%9F%8E%E5%B8%82%E7%9A%84SpringMVC%E7%A7%91%E6%8A%80%E5%9B%AD%E5%8C%BA/"/>
      <url>/2019/05/09/%E5%85%84%E5%BC%9F%E4%BF%A9%E7%95%85%E6%B8%B8Tomcat%E5%9F%8E%E5%B8%82%E7%9A%84SpringMVC%E7%A7%91%E6%8A%80%E5%9B%AD%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>今天看到一片文章挺有意思的,转了过来.</p><p>来自公众号：编程新说  李新杰</p><h2 id="Tomcat城市"><a href="#Tomcat城市" class="headerlink" title="Tomcat城市"></a>Tomcat城市</h2><p>Tomcat这座城市的历史相当悠久了，经历过几次大的变迁后，呈现出非常明显的地域特征。<br>从城市往西走，过了城乡结合部以后，可以说是满目疮痍、一片破败，这就是Servlet地区，这座城市一开始就是从这个地方发展起来的。<br>哎，这都是很多年前的老黄历了，只有一些老人才知道这些，现在的年轻人都不到这个地方来了，于是就荒芜了，快成无人区了。<br>城市的中央是Struts地区，人们习惯称它为老城区。矮矮的居民楼，窄窄的街道，三五成群的老旧工厂。<br>虽然现在没落了，但是置身其中，你依然能够感受到它曾经辉煌过的痕迹，那时也应该是灯红酒绿、人声鼎沸、好不热闹。<br>现在这里只剩下一些老年人了，年轻人觉得这里太陈旧了，都纷纷搬走了，偶尔能见到几个，那是回来看望父母的。<br>从城市往东走，出了老城进入新区，高楼大厦、玻璃幕墙，大宽马路、人流成河。红灯绿灯、南来北往，车声人声、声声不息。<br>这里充满了大量的年轻人，节奏感、时尚感、科技感，有梦想、有压力、有希望。没错，这就是大名鼎鼎、闻名遐迩的SpringMVC地区。<br>技术的发展就像城市的变迁，有新区就有老城。所谓长江后浪推前浪，一浪更比一浪浪，真是够浪，嗯，golang。</p><blockquote><p>第一代web应用Jsp+Servlet，现在基本没人用了，成了无人区了。<br>第二代web应用Struts1.x、Struts2，曾经辉煌时很多人用，现在都是进入维护期的老项目了，就像老城区。<br>第三代web应用SpringMVC，现在如日中天，依然是主战场，就如同城市的新区。</p><footer><strong>[编程新说]</strong></footer></blockquote><p>不过SpringMVC并非固若金汤，它的挑战者已经出现，就是响应式web应用，它现在不仅要面临外患，还有来自内忧的困扰。</p><h2 id="破旧的火车站"><a href="#破旧的火车站" class="headerlink" title="破旧的火车站"></a>破旧的火车站</h2><p>request奉主人之命，坐了“一夜”的火车，“长途跋涉”后来到了tomcat城市，按照约定，他的弟弟response会来这里接他。request刚下了车，他弟弟就迎了上来，没想到他跑到站台上来接自己了。<br>request边走边四处打量着，这座车站虽然略显破旧，但结构设计合理，层层叠叠、环环相扣，真是建筑之美啊。<br>他突然意识到自己是第一次来这里，还不知道路怎么走，看到不远处有一老者在扫地，打算前去问路。眼看就要到了，不料被四个人“截胡”了。<br>其中两个人说他们要找一个叫MyServlet的人，老者说出门往西走就行了。另外两个人说要找一个叫<code>FilterDispatcher</code>的人，老者说出门往前走就行了。<br>看着他们四人离去的背影，老者无奈地摇了摇头，又自顾自地开始扫地。request上去询问为何这般，老者解释道，这四位可是稀客啊，现在像他们这样的人已经很少了。几乎都是去找<code>DispatcherServlet</code>的人。<br>request说道，我们就是要去找<code>DispatcherServlet</code>呀，老者说，出门跟着人流走，保证能找到。为了礼貌，request询问了老者的姓名，老者说，他是Wrapper，在这里工作十几年了。<br>request和response跟老者道谢后，就离开了。出门后，好不容易挤上了一辆公交，一路向东奔去。</p><blockquote><p><em>MyServlet</em> 一般是一个刚毕业的学生起的名字。<br><em>FilterDispatcher</em> 是Struts2的核心控制器。<br><em>DispatcherServlet</em> 是SpringMVC的核心控制器。<br><em>Wrapper</em> 是Tomcat内部的一种容器组件，负责<em>Servlet</em>的调用执行。</p><footer><strong>[编程新说]</strong></footer></blockquote><h2 id="SpringMVC科技园区"><a href="#SpringMVC科技园区" class="headerlink" title="SpringMVC科技园区"></a>SpringMVC科技园区</h2><p> “前方到站SpringMVC科技园，有下车的乘客，请携带好随身物品，从后门下车”，两兄弟好不容易挤到后门，下车了。<br>眼前的这个科技园四四方方，里面的高大建筑布局合理。门前的宽大道路干净笔直，向南北无限延伸。旁边的小路绿树成荫、鲜花满地。<br>这里的一切都极具现代化都市气息，兄弟俩早已忘我。一阵急促的嘈杂声响起，哦，原来是绿灯亮了，可以过马路了，随机又淹没在人群中。<br>两兄弟在园区门口被保安拦下，“恁俩是弄啥嘞？”，保安问道。两兄弟一听，咦，河南人，心里乐了。说道，“老乡，俺是来找一个叫<code>DispatcherServlet</code>的人”。保安道，“那中，他一般都可忙啦，恁俩先去那边树荫下凉快凉快吧”。<br>一会儿功夫，有一个中年微胖男人来到了门口，就是他了。两兄弟表明来意后，request递上了一张“介绍信”，上面似乎写着：</p><pre><code>POST /users HTTP/1.1Content-Type: application/x-wwww-form-urlencodedAccept: application/jsonusername=abc&amp;password=1qaz@WSX&amp;email=xyz@456.com&amp;age=30</code></pre><p><code>DispatcherServlet</code>看后，心里暗骂一句，这是哪个小兔崽子在写着玩呢。不过人既然已经来了，那就按照程序走吧。<br>他就带着两兄弟来到了一个房间门口，说先进去检查一下，看看有没有“携带大件行李物品”。只见response准备进去，一把被他拉回来，说你不用去，只要你哥哥去就行了。<br>request来到门前，只见上面写着checkMultipart，推门而入，有个叫<code>MultipartResolver</code>的工作人员，正准备对他搜查，一看<code>Content-Type</code>，嘟囔着说原来只是普通表单提交没有附件，随即放弃了对request的检查，让他直接出去了。<br>request一脸懵逼，他原以为来到这里后，会有人专门带着他参观，给他讲解，端茶倒水啥的。谁知就像进了医院体检一样，拿个“单子”乱跑。<br>正在郁闷着的request在走过一个叫getHandler的房间门口时，被叫停了，他知道又该进去被检查了。一个叫<code>RequestMappingHandlerMapping</code>的家伙坐在电脑后面，request赶紧递上自己的单子。<br>那个家伙瞄了一眼单子后，在输入框里敲上“POST /users”关键字，点击搜索按钮，只见结果的第一条就是一个叫<code>UserController</code>的小伙子。并把这个小伙子的信息打印到一张纸上给了request。<br>request接过纸，边往外走边看，只见上面写着：</p><pre><code>HandlerExecutionChain:  handler:    HandlerMethod:      beanType: UserController      method: registerUser      parameters: [User]  interceptors: null</code></pre><p>request又是一脸懵逼，这都什么玩意儿呀。不过定睛一看，发现了熟悉的字眼儿。如UserController、registerUser、User。<br>request隐隐约约当中记得自己的主人写过一些和他们相关的东西，好像是这样的：</p><pre><code class="java">@RequestMapping(&quot;/users&quot;)@RestControllerpublic class UserController{  @Autowired  private IUserService userService;  @PostMapping  public RestResult registerUser(@ModelAttribute(&quot;user&quot;)User user){    userService.addUser(user);    return new RestResult(0,&quot;seccess&quot;);  }}public class User{  private String username;  private String password;  private String email;  private Integer age;}public class RestResult{  private Integer code;  private String desc;}</code></pre><p>此时，request仿佛明白了，刚才那个家伙根据我的“单子”，使用电脑搜索，为我开了个“方子”。说<code>UserController</code>这个小伙子的<code>registerUser</code>方法“可以治我的病”，其中<code>User</code>是方法入参。<br>request正准备沾沾自喜，怎么脑门突然一阵疼痛，莫非是得意忘形受了诅咒，哦，不是，是撞到门上了。揉了揉脑袋，便出了门。<br>三人一行继续往前走，request心里明白，现在这充其量叫作“做检查”，后面非给我来一个“大的修里”不可。又在一个叫做<code>getHandlerAdapter</code>的房间门口停住了。<br>不过这次两兄弟都在外面等着，是<code>DispatcherServlet</code>亲自拿着给request开的“方子”进去了。不一会他就出来了，又带出来一位叫<code>RequestMappingHandlerAdapter</code>的人，说这位是高级技工，由他来完成一部分核心工作。<br>这位高级技工带着两兄弟向自己的地盘走去，来到了一个写着handle的门前，推开门一起进入。这是一个非常大的房间，里面有好多的工作人员和机器设备，两兄弟明白，是时候了，重大的事情将在这里发生。<br>高级技工让两兄弟躺到工作台上，然后让所有人员各就各位，接着就是“生死看淡，不服就干”，于是，一切井然有序地开始了。<br>一个叫<code>ServletInvocableHandlerMethod</code>的家伙是本次的主要操盘手，他依次点名了自己的队友和检查了要用的设备，一切正常，下面正式开始了。<br>操盘手拿到给request开的“方子”，发现需要调用<code>registerUser</code>方法，于是先通过反射拿到这个方法的参数，再经过一番解析后变成了<code>MethodParameter</code>类型啦，对，它就表示方法的参数。<br>操盘手让他的队友<code>ParameterNameDiscoverer</code>去查看下参数的名字是什么，队友拿到参数，惊奇地发现上面有个<code>@ModelAttribute(&quot;user&quot;)</code>注解，于是从注解中读到了user，它就是参数的名字了。<br>操盘手又让他的队友<code>HandlerMethodArgumentResolver</code>去想办法把参数值搞定，队友也发现了<code>@ModelAttribute(&quot;user&quot;)</code>注解，说明这个参数是个模型数据，而且不是简单类型。于是先打开设备<code>ModelAndViewContainer</code>，发现设备里并没有一个叫user的数据。<br>队友明白，需要自己来生成这样的一个参数了。先拿到参数类型<code>User</code>，然后反射一下构造函数，发现正好有个默认无参的，通过它就new出了一个<code>User</code>类型的对象了。<br>队友接着反射一下它的属性，发现有4个，<em>username</em>、<em>password</em>、<em>email</em>、<em>age</em>。接着从request中恰巧能找出这4个名称的值，使用<code>WebDataBinderFactory</code>设备把数据类型合理转化后，设置给了user对象。这样队友就把参数值给准备好了。<br>有了<code>registerUser</code>方法和<code>user</code>参数后，还要知道在哪个对象上调用才行啊，于是操盘手根据方法所在的类型<code>UserController</code>，去容器中找到它的bean实例，接着就在该实例上通过反射发起了方法调用，传进去入参，并获取返回结果。<br>操盘手拿到返回结果，简单检查后发现返回结果不为null，再检查request的弟弟response，发现没有出现错误，而且还没有执行结束。于是在ModelAndViewContainer设备上把该请求标记为尚未处理完。<br>然后把返回结果交给队友<code>HandlerMethodReturnValueHandler</code>去处理，队友发现方法所在的类<code>UserController</code>上标有<code>@ResponseBody</code>注解（是作为<code>@RestController</code>的元注解出现的），瞬间就明白方法的返回值是直接作为web请求的响应的。<br>由于方法的返回值是要直接写入response的，所以就完事了，不用考虑视图解析这一块了。因此队友就在<code>ModelAndViewContainer</code>设备上把本次请求标记为已处理完成。<br>接着就把方法的返回值交给自己的好朋友<code>HttpMessageConverter</code>去处理，好朋友看了request的“单子”一眼，发现上面有<code>Accept：application/json</code>，瞬间也明白了，原来他想要的是JSON格式呀。<br>于是把方法返回值发给合作伙伴Jackson，不一会给他发回了结果，<code>{&quot;code&quot;:0,&quot;desc&quot;:&quot;success&quot;}</code>，好朋友把这个结果甩给了response，叫他拿好了。<br>好朋友完成了队友的任务，队友完成了操盘手的任务，操盘手向高级技工报告，任务已成功完成，请检阅。<br>高级技工本来打算输出一个<code>ModelAndView</code>作为处理结果呢，一检查<code>ModelAndViewContainer</code>设备发现请求已被处理完了。罢了，那就返回一个null吧。<br>门开了，两兄弟出来了，哥哥request已被“消耗殆尽”，弟弟response“满载而归”。<code>DispatcherServlet</code>早已在此等候，他看到高级技工手里只有一个null，于是记录了一句话，“No view rendering, null ModelAndView returned.”。<br>两兄弟和<code>DispatcherServlet</code>道谢后来到了园区大门口，接着和老乡保安挥手告别。此时天色已晚，挤上一辆公交车后，直奔火车站而去。</p><h2 id="就此一别，再无相见"><a href="#就此一别，再无相见" class="headerlink" title="就此一别，再无相见"></a>就此一别，再无相见</h2><p>一路摇摇晃晃来到火车站，天已完全黑透了。返程的列车早已整装待发，弟弟response拉着哥哥的手准备一起上车，被哥哥拒绝了，哥哥说按照剧情应该只有你一个人回去。我的使命已完成了。<br>弟弟并不明白哥哥是什么意思，就问道那我们还能不能再见面。哥哥笑着说傻孩子，“当然可以了”。弟弟高兴地跳上了车。<br>伴着一声长鸣，列车启动，兄弟俩互相挥手告别，列车渐渐消失在黑夜的黑中。弟弟没有看到哥哥微笑的眼角流下了流水。<br>只有哥哥心里明白，他和弟弟，就此一别，再无相见。转身向车站外走去，看到那个老者依然在自顾自的扫着地。<br>黑白无常拿着脚镣手铐，早已在此“恭候多时”，有气无力的request全然无法反抗，任由这“二鬼”拖着去“阴曹地府”接受JVM的轮回。<br>也许老天不愿意看到一个光荣完成使命的人就这般的“烟消玉损”，就派出了钟馗来解救他。钟馗打跑了黑白无常，希望带request“永生”。<br>request婉言拒绝，说我非“三界五行”之外，我依然是凡人，依然有自己的宿命。这是任何人都无法逃离的自然规律。<br>顷刻，一束白光从天而降，洒满request的全身，只见request张开双臂，身轻如燕般的飞向光的源头，不一会便没有了踪迹。</p>]]></content>
      
      
      <categories>
          
          <category> springMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务不停服升级</title>
      <link href="/2019/05/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%81%9C%E6%9C%8D%E5%8D%87%E7%BA%A7/"/>
      <url>/2019/05/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%81%9C%E6%9C%8D%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>有时候我们会给生产环境修复一些比较严重的bug,有没有一种操作可以不停服进行系统升级呢?<br>答案是: <strong>有的</strong>.</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>生产环境部署在阿里云acs-swarm上.<br>服务注册使用eureka.</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先新增新版本的服务实例到生产环境,待新版本服务开始服务之后,通知注册中心下线老版本服务(此时老版本服务不停机,还可以提供服务,只是不会在收到新的请求了),观察监控 等待老版本服务处理完所有请求之后,停机老版本服务,至此完成不停服升级.<br>原理挺简单,关键看操作.</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><ol><li><p>打包要升级的服务,并推送到阿里云镜像服务.</p></li><li><p>进入阿里云后台容器服务,选择服务所在集群,选择相应的应用 点变更配置.<br>找到相应的服务,修改一下服务名称,比如 user-service 修改成 user-service-1,在修改一下服务镜像的版本号,还有acs应用的版本号.<br><strong>注意发布类型要选蓝绿发布</strong></p><img src="/2019/05/09/微服务不停服升级/1.png"><p>确定之后稍等片刻,你会发现,你的容器服务列表新增了一个user-service-1的服务. eureka服务器上user-service的实例也多了一个.</p></li><li><p>通知注册中心下线老版本服务</p><pre><code class="bash">curl -X PUT http://eureka-server:8761/eureka/app/{SERVICE-NAME}/{SERVICE-ID}/status?value=OUT_OF_SERVICE</code></pre><p>把{}中的内容替换成实际内容.<br>你会发现eureka会给这个实例标记一个 红色的 OUT_OF_SERVICE,这样eureka client就不会获取到这个实例的注册信息了,网关也不会讲流量转发到这个实例上来了.</p></li><li><p>看监控下线老版本服务.<br>你会发现老服务的流量会越来越少.</p><img src="/2019/05/09/微服务不停服升级/2.png"><p>当老服务处理完所有请求的时候,到阿里云acs控制台,选择确认发布.</p></li></ol><p>搞定,收工.</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 升级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-data-jpa进阶用法之QueryDSL</title>
      <link href="/2019/05/07/spring-data-jpa%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%E4%B9%8BQueryDSL/"/>
      <url>/2019/05/07/spring-data-jpa%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%E4%B9%8BQueryDSL/</url>
      
        <content type="html"><![CDATA[<p>很多列表查询接口都会有很多复杂的过滤条件。一般都会在controller里面各种拼接条件然后在持久层写好多针对性的查询接口，导致代码可读性差，实现不够优雅。</p><h3 id="QueryDSL"><a href="#QueryDSL" class="headerlink" title="QueryDSL"></a>QueryDSL</h3><p>其实QueryDsl可以很优雅的解决上述场景遇到的问题，QueryDSL是一个Java语言编写的通用查询框架。spring-data-jpa对QueryDsl提供了良好的支持。同时spring-data-jpa也针对web做了一些扩展支持。具体可以参考<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.extensions.querydsl" target="_blank" rel="noopener">spring-data-jpa的官方文档</a>。</p><h3 id="spring-data-jpa的支持"><a href="#spring-data-jpa的支持" class="headerlink" title="spring-data-jpa的支持"></a>spring-data-jpa的支持</h3><p>持久层repository继承<code>QuerydslPredicateExecutor</code>，即可使用QueryDsl查询。</p><pre><code class="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, QuerydslPredicateExecutor&lt;User&gt; {}Predicate predicate = user.firstname.equalsIgnoreCase(&quot;dave&quot;)    .and(user.lastname.startsWithIgnoreCase(&quot;mathews&quot;));userRepository.findAll(predicate);</code></pre><p>web层可以使用 @QuerydslPredicate 标注Predicate。</p><pre><code class="java">@Controllerclass UserController {  @Autowired UserRepository repository;  @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,              Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt; parameters) {    model.addAttribute(&quot;users&quot;, repository.findAll(predicate, pageable));    return &quot;index&quot;;  }}</code></pre><p>这样包含 ?firstname=Dave&amp;lastname=Matthews的查询将会被<code>QuerydslPredicateArgumentResolver</code>解析成 <code>QUser.user.firstname.eq(&quot;Dave&quot;).and(QUser.user.lastname.eq(&quot;Matthews&quot;))</code></p><p>有时候我们的参数并不是和实体的属性一一对应，甚至我们需要隐藏一些不可以用来查询的属性。</p><h3 id="自定义绑定关系"><a href="#自定义绑定关系" class="headerlink" title="自定义绑定关系"></a>自定义绑定关系</h3><p>我们可一通过实现 <code>QuerydslBinderCustomizer</code>这个接口来自定义参数的绑定关系。</p><pre><code class="java">CustomUserQuerydslBinder implements QuerydslBinderCustomizer&lt;QUser&gt; {    @Override    public void customize(QuerydslBindings querydslBindings, QUser qUser) {      //自定义绑定关系      querydslBindings.excludeUnlistedProperties(true);//使用白名单模式      querydslBindings.including( //设置属性白名单            qUser.id,            qUser.name      );      //自定义参数的绑定       querydslBindings.bind(Expressions.stringPath(&quot;sex&quot;)).as(&quot;type&quot;).first((path,value)-&gt;            path.eq(value)        );    }}</code></pre><p>然后在 <code>@QuerydslPredicate(bindings=CustomUserQuerydslBinder.class,root=User.class)</code>中指定。</p>]]></content>
      
      
      <categories>
          
          <category> jpa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qdsl </tag>
            
            <tag> jpa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非spring-cloud项目增加hystrix监控</title>
      <link href="/2019/05/07/%E9%9D%9Espring-cloud%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%8A%A0hystrix%E7%9B%91%E6%8E%A7/"/>
      <url>/2019/05/07/%E9%9D%9Espring-cloud%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%8A%A0hystrix%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="增加依赖"><a href="#增加依赖" class="headerlink" title="增加依赖"></a>增加依赖</h2><p>pom文件中</p><pre><code class="xml"> &lt;dependency&gt;  &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;  &lt;artifactId&gt;hystrix-metrics-event-stream&lt;/artifactId&gt;  &lt;version&gt;${hystrix.version}&lt;/version&gt; &lt;/dependency&gt;</code></pre><h2 id="添加servlet"><a href="#添加servlet" class="headerlink" title="添加servlet"></a>添加servlet</h2><p>web.xml 中</p><pre><code class="xml">  &lt;servlet&gt;    &lt;display-name&gt;HystrixMetricsStreamServlet&lt;/display-name&gt;    &lt;servlet-name&gt;HystrixMetricsStreamServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet    &lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;HystrixMetricsStreamServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/hystrix.stream&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;</code></pre><h2 id="增加Basic安全认证"><a href="#增加Basic安全认证" class="headerlink" title="增加Basic安全认证"></a>增加Basic安全认证</h2><p>web.xml 中</p><pre><code class="xml">&lt;filter&gt;    &lt;filter-name&gt;basicAuthenticationFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.dapeng.cloud.support.web.BasicAuthenticationFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;username&lt;/param-name&gt;      &lt;param-value&gt;xxxx&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;password&lt;/param-name&gt;      &lt;param-value&gt;xxxx&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;basicAuthenticationFilter&lt;/filter-name&gt;    &lt;servlet-name&gt;HystrixMetricsStreamServlet&lt;/servlet-name&gt;  &lt;/filter-mapping&gt;</code></pre><p><code>BasicAuthenticationFilter</code> 源码:</p><pre><code class="java">package com.dapeng.cloud.support.web;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.StringTokenizer;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.codec.binary.Base64;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.StringUtils;public class BasicAuthenticationFilter implements Filter {  private static final Logger LOGGER = LoggerFactory.getLogger(BasicAuthenticationFilter.class);  private String username = &quot;&quot;;  private String password = &quot;&quot;;  private String realm = &quot;Protected&quot;;  public BasicAuthenticationFilter() {  }  public void init(FilterConfig filterConfig) throws ServletException {    this.username = filterConfig.getInitParameter(&quot;username&quot;);    this.password = filterConfig.getInitParameter(&quot;password&quot;);    String paramRealm = filterConfig.getInitParameter(&quot;realm&quot;);    if (StringUtils.hasText(paramRealm)) {      this.realm = paramRealm;    }  }  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {    HttpServletRequest request = (HttpServletRequest)servletRequest;    HttpServletResponse response = (HttpServletResponse)servletResponse;    String authHeader = request.getHeader(&quot;Authorization&quot;);    if (authHeader != null) {      StringTokenizer st = new StringTokenizer(authHeader);      if (st.hasMoreTokens()) {        String basic = st.nextToken();        if (basic.equalsIgnoreCase(&quot;Basic&quot;)) {          try {            String credentials = new String(Base64.decodeBase64(st.nextToken()), &quot;UTF-8&quot;);            LOGGER.debug(&quot;Credentials: &quot; + credentials);            int p = credentials.indexOf(&quot;:&quot;);            if (p != -1) {              String _username = credentials.substring(0, p).trim();              String _password = credentials.substring(p + 1).trim();              if (this.username.equals(_username) &amp;&amp; this.password.equals(_password)) {                filterChain.doFilter(servletRequest, servletResponse);              } else {                this.unauthorized(response, &quot;Bad credentials&quot;);              }            } else {              this.unauthorized(response, &quot;Invalid authentication token&quot;);            }          } catch (UnsupportedEncodingException var13) {            throw new Error(&quot;Couldn&#39;t retrieve authentication&quot;, var13);          }        }      }    } else {      this.unauthorized(response);    }  }  public void destroy() {  }  private void unauthorized(HttpServletResponse response, String message) throws IOException {    response.setHeader(&quot;WWW-Authenticate&quot;, &quot;Basic realm=\&quot;&quot; + this.realm + &quot;\&quot;&quot;);    response.sendError(401, message);  }  private void unauthorized(HttpServletResponse response) throws IOException {    this.unauthorized(response, &quot;Unauthorized&quot;);  }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/07/hello-world/"/>
      <url>/2019/05/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><pre><code class="javascript">console.log(1)</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本博客快捷键说明</title>
      <link href="/2019/05/07/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/05/07/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>快捷键为vim风格的。按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h3><table><thead><tr><th style="text-align:left">Key</th><th style="text-align:left">Descption</th></tr></thead><tbody><tr><td style="text-align:left">ESC</td><td style="text-align:left">1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点</td></tr><tr><td style="text-align:left">i/I</td><td style="text-align:left">获取焦点</td></tr><tr><td style="text-align:left">下</td><td style="text-align:left">向下选择文章</td></tr><tr><td style="text-align:left">上</td><td style="text-align:left">向上选择文章</td></tr><tr><td style="text-align:left">回车</td><td style="text-align:left">打开当前选中的文章，若没有，则默认打开第一个</td></tr></tbody></table><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><table><thead><tr><th style="text-align:left">Key</th><th style="text-align:left">Descption</th></tr></thead><tbody><tr><td style="text-align:left">s/S</td><td style="text-align:left">全屏/取消全屏</td></tr><tr><td style="text-align:left">w/W</td><td style="text-align:left">打开/关闭文章目录</td></tr><tr><td style="text-align:left">j/J</td><td style="text-align:left">向下滑动</td></tr><tr><td style="text-align:left">k/K</td><td style="text-align:left">向上滑动</td></tr><tr><td style="text-align:left">gg/GG</td><td style="text-align:left">到最顶端</td></tr><tr><td style="text-align:left">shift+G/g</td><td style="text-align:left">到最下端</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
